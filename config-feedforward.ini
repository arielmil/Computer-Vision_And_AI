[NEAT]
# Caso fitness_criterion seja atingido, define se o fitness a ser comparado com fitness criterion √© o m√°ximo, m√≠nimo ou m√©dia.
fitness_criterion     = mean

# Define o valor m√≠nimo de fitness necess√°rio para encerrar a evolu√ß√£o
fitness_threshold     = 0.70

# Define o tamanho da popula√ß√£o em cada gera√ß√£o
pop_size              = 150

# Se ativado, reseta a popula√ß√£o se todas as esp√©cies forem extintas
reset_on_extinction   = False

[DefaultGenome]
# ========================== ATIVA√á√ÉO DOS N√ìS ==========================
# üìå O que √© uma fun√ß√£o de ativa√ß√£o?
# A fun√ß√£o de ativa√ß√£o define como um neur√¥nio processa sua entrada e gera uma sa√≠da.
# Em redes neurais, os neur√¥nios recebem um valor (soma ponderada das entradas),
# aplicam essa fun√ß√£o de ativa√ß√£o e retornam o resultado.
# Exemplos comuns:
# - Sigmoid: comprime a sa√≠da para o intervalo (0,1), √∫til para probabilidades.
# - Tanh: comprime a sa√≠da para (-1,1), √∫til para dados centralizados em 0.
# - ReLU: zera valores negativos e mant√©m os positivos, eficiente para aprendizado profundo.
# - ELU: variante da ReLU, reduz problemas de "dying ReLU".

activation_default      = sigmoid
activation_mutate_rate  = 0.35
activation_options      = sigmoid tanh relu elu

# ========================== AGREGA√á√ÉO DOS N√ìS ==========================
# üìå O que √© uma fun√ß√£o de agrega√ß√£o?
# Em uma rede neural, cada neur√¥nio pode receber m√∫ltiplas conex√µes de entrada.
# A fun√ß√£o de agrega√ß√£o define como essas entradas s√£o combinadas antes da ativa√ß√£o.
# Exemplos comuns:
# - Sum (soma): soma todas as entradas antes da ativa√ß√£o (mais comum).
# - Mean (m√©dia): tira a m√©dia dos valores das entradas antes da ativa√ß√£o.
# - Max (m√°ximo): escolhe o maior valor de entrada.
# Essa etapa acontece **antes** da fun√ß√£o de ativa√ß√£o.

aggregation_default     = sum
aggregation_mutate_rate = 0.0
aggregation_options     = sum

# ========================== ADI√á√ÉO/REMO√á√ÉO DE CONEX√ïES ==========================
conn_add_prob       = 0.85
conn_delete_prob    = 0.40

# ========================== ADI√á√ÉO/REMO√á√ÉO DE N√ìS ==========================
node_add_prob       = 0.85
node_delete_prob    = 0.40

# ========================== HABILITA√á√ÉO/DESABILITA√á√ÉO DE CONEX√ïES ==========================
enabled_default         = False
enabled_mutate_rate     = 0.55

# ========================== ESTRUTURA INICIAL DA REDE ==========================
feed_forward            = True
initial_connection      = full_nodirect

# ========================== ESTRUTURA DA REDE NEURAL ==========================
num_hidden              = 0
num_inputs              = 400
num_outputs             = 10

# ========================== PAR√ÇMETROS DE RESPOSTA DOS N√ìS ==========================
# üìå O que √© a resposta de um neur√¥nio?
# A resposta define um fator multiplicativo aplicado √† sa√≠da do neur√¥nio antes de ser propagada.
# Em alguns modelos, a resposta pode ser ajustada para aumentar ou reduzir a sensibilidade
# do neur√¥nio. No entanto, neste caso, as muta√ß√µes de resposta est√£o desativadas.
#
# Qual a diferen√ßa entre response, e activation?
#
# Em activation, a fun√ß√£o de ativa√ß√£o √© aplicada diretamente ao valor de entrada do neur√¥nio
# Por exemplo, se a ativa√ß√£o for sigmoid, a sa√≠da ser√° sigmoid(valor_de_entrada)
# Ent√£o se o valor de entrada for 482, a sa√≠da ser√° sigmoid(482)
# Que √© 1/(1+exp(-482)) ‚âà 1
#
# Em response, a sa√≠da do neur√¥nio √© multiplicada por um fator de resposta
# Por exemplo, se a resposta daquele neuronio com ativa√ß√£o de sigmoid for 0.5, a sa√≠da ser√° sigmoid(valor_de_entrada) * 0.5
# Se o valor de entrada for 482, a sa√≠da ser√° sigmoid(482) * 0.5
# Que √© 1/(1+exp(-482)) * 0.5 ‚âà 0.5

response_init_mean      = 1.0
response_init_stdev     = 0.2
response_max_value      = 2
response_min_value      = -2
response_mutate_power   = 0.20
response_mutate_rate    = 0.20
response_replace_rate   = 0.05

# ========================== PESOS DAS CONEX√ïES ==========================
weight_init_mean        = 0.0
weight_init_stdev       = 0.5
weight_max_value        = 5
weight_min_value        = -5
weight_mutate_power     = 0.40
weight_mutate_rate      = 0.55
weight_replace_rate     = 0.10

# ========================== PAR√ÇMETROS DO VI√âS (BIAS) ==========================
bias_init_mean          = 0.0
bias_init_stdev         = 1.2
bias_max_value          = 5
bias_min_value          = -5
bias_mutate_power       = 0.40
bias_mutate_rate        = 0.55
bias_replace_rate       = 0.10

# ========================== CONTROLE DE MUTA√á√ïES ESTRUTURAIS ==========================
single_structural_mutation = False
structural_mutation_surer = True

# ========================== COMPATIBILIDADE ENTRE GENOMAS ==========================
# üìå O que s√£o os coeficientes de compatibilidade?
# O NEAT separa redes neurais em diferentes esp√©cies para evitar que muta√ß√µes boas sejam
# perdidas ao competir diretamente com outras configura√ß√µes ruins. Para isso, ele mede
# a diferen√ßa entre dois genomas usando dois coeficientes:
# 
# 1Ô∏è‚É£ **compatibility_disjoint_coefficient**: Penaliza diferen√ßas estruturais entre genomas,
# ou seja, avalia quantos n√≥s e conex√µes existem em um genoma, mas n√£o no outro.
# Se for alto, redes com topologias muito diferentes ser√£o separadas mais rapidamente.
#
# 2Ô∏è‚É£ **compatibility_weight_coefficient**: Mede a diferen√ßa nos pesos das conex√µes comuns entre
# dois genomas. Se for alto, pequenas mudan√ßas nos pesos levar√£o a separa√ß√£o das esp√©cies.
#
# O c√°lculo da compatibilidade entre dois genomas √©:
# ```
# Œ¥ = (C1 * disjoint) + (C2 * weight_diff)
# ```
# onde:
# - `disjoint` √© o n√∫mero de conex√µes √∫nicas entre os genomas.
# - `weight_diff` √© a diferen√ßa m√©dia dos pesos entre conex√µes equivalentes.
# - `C1` e `C2` s√£o os coeficientes definidos abaixo.
#
# E o que ele faz com esse valor:
# - Se `Œ¥` for menor que o limiar de compatibilidade, os genomas s√£o considerados compat√≠veis e pertencem √† mesma esp√©cie.
# - Se for maior, eles s√£o incompat√≠veis e s√£o separados em esp√©cies diferentes.

compatibility_disjoint_coefficient = 2.5
compatibility_weight_coefficient   = 0.8

[DefaultSpeciesSet]
# üìå Como o limiar de compatibilidade separa indiv√≠duos em esp√©cies?
# O NEAT agrupa redes neurais em esp√©cies para proteger muta√ß√µes inovadoras e evitar que
# todas as redes se tornem muito semelhantes rapidamente. Isso acontece assim:
#
# 1Ô∏è‚É£ Um novo genoma √© comparado com um genoma representativo de cada esp√©cie existente.
# 2Ô∏è‚É£ Se a diferen√ßa de compatibilidade (Œ¥) for menor que o limiar definido abaixo, o genoma
#     √© adicionado √†quela esp√©cie.
# 3Ô∏è‚É£ Se n√£o houver nenhuma esp√©cie compat√≠vel, uma nova esp√©cie √© criada para esse genoma.
#
# Se o limiar for **muito baixo**, todas as redes acabam na mesma esp√©cie, reduzindo a diversidade.
# Se for **muito alto**, h√° muitas esp√©cies pequenas, o que pode impedir um aprendizado eficiente.

compatibility_threshold = 3.0

# ========================== PAR√ÇMETROS DE ESTAGNA√á√ÉO ==========================
# üìå O que √© estagna√ß√£o?
# A estagna√ß√£o ocorre quando uma esp√©cie n√£o melhora seu fitness por um n√∫mero de gera√ß√µes.
# Para evitar que recursos sejam desperdi√ßados em esp√©cies que n√£o est√£o evoluindo,
# o NEAT define um limite de estagna√ß√£o. Se uma esp√©cie n√£o melhorar por esse n√∫mero de gera√ß√µes,
# ela √© considerada estagnada e pode ser removida.

[DefaultStagnation]
species_fitness_func = mean
max_stagnation       = 15
species_elitism      = 9

[DefaultReproduction]
elitism            = 4
survival_threshold = 0.3

# ========================== PAR√ÇMETROS DE MUTA√á√ÉO ==========================
min_species_size = 6